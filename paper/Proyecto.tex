\documentclass[12pt]{article}
\usepackage[margin=1in]{geometry} 
\usepackage{amsmath,amsthm,amssymb,amsfonts}
\usepackage[spanish]{babel}
\usepackage[utf8]{inputenc}
\usepackage{mathtools}
\usepackage{hyperref}
\selectlanguage{spanish}
\newcommand{\N}{\mathbb{N}}
\newcommand{\Z}{\mathbb{Z}}
\usepackage{color}
\usepackage{graphicx}
\usepackage[noend]{algorithmic}

\newenvironment{solution}
  {\renewcommand\qedsymbol{$\blacksquare$}\begin{proof}[Solución]}
  {\end{proof}}

\newcommand{\TITLE}[1]{\item[#1]}

\renewcommand{\algorithmiccomment}[1]{$/\!/$ \parbox[t]{4.5cm}{\raggedright #1}}
% ugly hack for for/while
\newbox\fixbox
\renewcommand{\algorithmicdo}{\setbox\fixbox\hbox{\ {} }\hskip-\wd\fixbox}
% end of hack
%imitando para if
\renewcommand{\algorithmicthen}{\setbox\fixbox\hbox{\ {} }\hskip-\wd\fixbox}
\newcommand{\algcost}[2]{\strut\hfill\makebox[1.5cm][l]{#1}\makebox[4cm][l]{#2}}

%piso techo 
\DeclarePairedDelimiter\ceil{\lceil}{\rceil}
\DeclarePairedDelimiter\floor{\lfloor}{\rfloor}
 
 \newenvironment{ejercicio}[2][Ejercicio]{\begin{trivlist}
\item[\hskip \labelsep {\bfseries #1}\hskip \labelsep {\bfseries #2.}]}{\end{trivlist}}

\newenvironment{problem}[2][Problem]{\begin{trivlist}
\item[\hskip \labelsep {\bfseries #1}\hskip \labelsep {\bfseries #2.}]}{\end{trivlist}}


\title{Proyecto de ADA - Primer Avance}
\author{Alejandro Goicochea \and Diego Linares \and Ariana Villegas}
\date{16 de Junio del 2020}

\begin{document}
\maketitle

\section*{Secuencias}

\subsection*{Pregunta 1 (Voraz)}

\subsubsection*{Algoritmo: Get-Blocks}

\noindent Recibe: Un arreglos A de ceros y unos.

\noindent Devuelve: Un arreglo X de bloques de unos. 

\begin{algorithmic}[1]
  \TITLE{\textsc{Get-Blocks}$(A,p)$}
    \algcost{\textit{cost}}{\textit{times}}
  \STATE i = 1
    \algcost{$c_1$}{$1$}
  \STATE j = 1
    \algcost{$c_1$}{$1$}
  \WHILE{$i\leq p$
    \algcost{$c_3$}{$1$}}
  \STATE tmp = 0
    \algcost{$c_1$}{$1$}
    \WHILE{$A[i]\neq 1$
      \algcost{$c_4$}{$1$}}
    \STATE i += 1
      \algcost{$c_5$}{$0$}
    \ENDWHILE
    \WHILE{$A[i]\neq 0$
      \algcost{$c_4$}{$p+1$}}
    \STATE i += 1
      \algcost{$c_5$}{$p$}
    \STATE tmp += 1
      \algcost{$c_5$}{$p$}
    \ENDWHILE
  	\IF{tmp $\neq 0$ \algcost{$c_6$}{$1$}} 
    \STATE X[j] = tmp
      \algcost{$c_7$}{$1$}
    \STATE j += 1
      \algcost{$c_5$}{$1$}
    \ENDIF 
  \ENDWHILE
  \STATE return X
    \algcost{$c_8$}{$1$}
\end{algorithmic} 

\subsubsection*{Tiempo de ejecución: Get-Blocks}

\noindent Para T(p) el tiempo de ejecución con un array de tamaño p como entrada, tenemos que
\begin{eqnarray*}
T(p)&=&c_1+c_1+c_3+c_1+c_4+c_4\cdot (p+1)+c_5\cdot p+c_5\cdot p+c_6+c_7+c_5+c_8 \\
T(p)&=&c_4\cdot p+2c_5\cdot p+3c_1+c_3+2c_4+c_5+c_6+c_7+c_8 
\end{eqnarray*}

\noindent Si $a=c_4+2c_5$ y $b=3c_1+c_3+2c_4+c_5+c_6+c_7+c_8$, entonces
$$T(p)=ap+b$$

\noindent \textbf{Nota: } Para el análisis de los algoritmos propuestos en los siguientes apartados no se tomará en cuenta el tiempo de generar los bloques en los array de entrada.

\subsubsection*{Algoritmo: Min-Matching-Greedy}

\noindent Recibe: Dos arreglos A y B de ceros y unos de tamaño p, con n bloques y m bloques respectivamente (los valores de n y m no son recibidos como entrada). 

\noindent Devuelve: Un matching entre A y B, no necesariamente óptimo, y su peso.

\begin{algorithmic}[1]
  \TITLE{\textsc{Min-Matching-Greedy}$(A,B)$}
    \algcost{\textit{cost}}{\textit{times}}
  \STATE X = Get-Blocks(A,p)
    \algcost{$.$}{$.$}
  \STATE Y = Get-Blocks(B,p)
    \algcost{$.$}{$.$}
  \STATE n = X.size
    \algcost{$c_1$}{$1$}
  \STATE m = Y.size
    \algcost{$c_2$}{$1$}  
  \STATE Match = $\emptyset$
    \algcost{$c_3$}{$1$}
  \STATE $w = 0$
    \algcost{$c_4$}{$1$}
  \FOR{$i=1$ TO $min(n,m)-1$
    \algcost{$c_5$}{$m$}}  
  \STATE Match = Match $\cup \ \{\{i,i\}\}$
    \algcost{$c_6$}{$m-1$}
  \STATE $w$ += X[i]/Y[i]
    \algcost{$c_7$}{$m-1$}
  \ENDFOR  
  \IF{$n>m$ \algcost{$c_8$}{$1$}} 
    \FOR{$i=0$ TO $n-m$
    \algcost{$c_5$}{$n-m+1$}}  
    \STATE Match = Match $\cup \ \{\{m+i,m\}\}$
      \algcost{$c_6$}{$n-m$}
    \STATE $w$ += X[m+i]/Y[m]
      \algcost{$c_7$}{$n-m$}
    \ENDFOR 
  \ELSE
    \FOR{$i=0$ TO $n-m$
    \algcost{$c_5$}{$0$}}  
    \STATE Match = Match $\cup \ \{\{n,n+i\}\}$
      \algcost{$c_6$}{$0$}
    \STATE $w$ += X[n]/Y[n+i]
      \algcost{$c_7$}{$0$}
    \ENDFOR 
  \ENDIF 
  
  \STATE return $w$, Match
    \algcost{$c_9$}{$1$}
\end{algorithmic}

\subsubsection*{Tiempo de ejecución: Min-Matching-Greedy}

\noindent Para T(n,m) el tiempo de ejecución con un array de tamaño p como entrada, tenemos que
\begin{eqnarray*}
T(n,m)&=&c_1+c_2+c_3+c_4+c_5\cdot m+c_6\cdot (m-1)+c_7\cdot (m-1)+c_8+c_5\cdot (n-m+1)+\\
& &c_6\cdot (n-m)+c_7\cdot (n-m)+c_9 \\
T(n,m)&=&c_5\cdot m+c_6\cdot m+c_7\cdot m-c_5\cdot m-c_6\cdot m-c_7\cdot m+c_5\cdot n+c_6\cdot n+c_7\cdot n+c_1 \\
& &+c_2+c_3+c_5-c_6-c_7+c_8+c_9 
\end{eqnarray*}

\noindent Si $a=c_5+c_6+c_7-c_5-c_6-c_7=0$, $b=c_5+c_6+c_7$ y $c=c_1+c_2+c_3+c_5-c_6-c_7+c_8+c_9$, entonces si $n>m$
$$T(n,m)=bn+c$$
Y si $m>n$, tenemos que
$$T(n,m)=am+c$$
Entonces, podemos generalizarlo como
$$T(n,m)=max(am,bn)+c$$


\noindent \textbf{Prueba que $T(n) = O(max(n,m))$} \\

\noindent Note que para $n_0\geq max(a,b)+1$, tenemos que 
\begin{eqnarray*}
max(am,bn)+c &\leq& max(max(a,b)\cdot m, max(a,b)\cdot n)+c \\
&\leq& max(a,b)\cdot max(m,n)+c \\
&\leq& (max(a,b)+1)\cdot max(m,n) \\
&\leq& n_0\cdot max(m,n)
\end{eqnarray*}

\noindent Y como la función $max$ es creciente, tenemos que
\begin{eqnarray*}
0\leq max(am,bn)\leq n_0\cdot max(m,n)
\end{eqnarray*}
\noindent Entonces por definición, concluimos que $T(n) = O(max(n,m))$

\subsection*{Pregunta 2 (Recurrencia)}

\noindent Asumimos que:\\
$X = \textsc{Get-Blocks}(A,p)$ \\
$Y = \textsc{Get-Blocks}(B,p)$ 

\[
OPT(i,j)=\left\{
            \begin{array}{ll}
              \frac{X_i}{Y_j} \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ i=1 \ \ \wedge \ \ j=1 \\ \\
              \frac{X_i}{\sum_{p=1}^{j}Y_p} \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ i=1 \ \ \wedge \ \ j>1 \\ \\
              \frac{\sum_{p=1}^{i}X_p}{Y_j} \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ i>1 \ \ \wedge \ \ j=1 \\ \\
              min(M_g(i,j), M_d(i,j)) \ \ \ \ \ \ \ \ \ \ \ \ \ \  \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ i>1 \ \ \wedge \ \ j>1 \\
            \end{array}
          \right.
\]

\noindent
$M_g(i,j) = min_{k=1}^{i-1}\{\frac{\sum_{p=k+1}^{i}X_p}{Y_j} + OPT(k,j-1)\}$ \\ \\
$M_d(i,j) = min_{k=1}^{j-1}\{\frac{X_i}{\sum_{p=k+1}^{j}Y_p} + OPT(i-1,k)\}$

\subsection*{Pregunta 3 (Recursivo)}

\noindent Asumimos que:\\
$X = \textsc{Get-Blocks}(A,p)$ \\
$Y = \textsc{Get-Blocks}(B,p)$ 

\subsubsection*{Algoritmo: Group}

\begin{algorithmic}[1]
  \TITLE{\textsc{Group}$(X,Y,i,j)$}
    \algcost{\textit{cost}}{\textit{times}}
  \STATE Min = $\infty$
    \algcost{$c_1$}{$1$}
  \FOR{$k=1$ TO $i-1$ \algcost{$c_2$}{$i$}}  
    \STATE accum = 0
      \algcost{$c_3$}{$i-1$}
    \FOR{$p=k+1$ TO $i$ \algcost{$c_4$}{$\frac{(i-2)(i-1)}{2}$}}  
      \STATE accum += $X[p]$
        \algcost{$c_5$}{$\frac{(i-2)(i-1)}{2}$}
    \ENDFOR  
    \STATE accum /= $Y[j]$
      \algcost{$c_6$}{$i-1$}
    \STATE match, pmin = \textsc{Min-Matching-Recursive}$(X,Y,k,j-1)$ \\
      \algcost{$T_m(i-1,j-1)$}{$\ \ \ \ \ \ \ \ \ \ \ \ 2$}
    \IF{Min$>$accum+pmin \algcost{$c_7$}{$i-1$}} 
      \STATE Min = accum + pmin
        \algcost{$c_8$}{$i-1$}
      \STATE Match = match
        \algcost{$c_9$}{$i-1$}
    \ENDIF 
  \ENDFOR  
  \RETURN Match$\ \cup \ \{[i,j]\},$ Min
    \algcost{$c_1$}{$1$}
\end{algorithmic}

\subsubsection*{Tiempo de ejecución: Group}

\noindent Para $T_g(i,j)$ el tiempo de ejecución con un array de tamaño p como entrada, tenemos que
\begin{eqnarray*}
T_g(i,j)&=&c_1+c_2+c_3\cdot (i-1)+c_4\cdot \frac{(i-2)(i-1)}{2}+c_5\cdot \frac{(i-2)(i-1)}{2}+c_6\cdot (i-1)+\\
& &2\cdot T_m(i-1,j-1)+c_7\cdot (i-1)+c_8\cdot (i-1)+c_9\cdot (i-1)+c_1\\
T_g(i,j)&=&2\cdot T_m(i-1,j-1)+\frac{c_4}{2}\cdot i^2+\frac{c_5}{2}\cdot i^2-3c_4\cdot i-3c_5\cdot i+c_6\cdot i+c_7\cdot i+ \\
& &c_8\cdot i+c_9\cdot i+2c_1+c_2-c_3+3c_4+3c_5-c_6-c_7-c_8-c_9 
\end{eqnarray*}

\noindent Si $a=\frac{c_4}{2}+\frac{c_5}{2}$, $b=-3c_4-3c_5+c_6+c_7+c_8+c_9$ y $c=2c_1+c_2-c_3+3c_4+3c_5-c_6-c_7-c_8-c_9$, entonces
$$T_g(i,j)=2\cdot T_m(i-1,j-1)+ai^2+bi+c$$


\subsubsection*{Algoritmo: Division}

\begin{algorithmic}[1]
  \TITLE{\textsc{Division}$(X,Y,i,j)$}
    \algcost{\textit{cost}}{\textit{times}}
  \STATE Min = $\infty$
    \algcost{$c_1$}{$1$}
  \FOR{$k=1$ TO $j-1$ \algcost{$c_2$}{$j$}}  
    \STATE accum = 0
      \algcost{$c_3$}{$j-1$}
    \FOR{$p=k+1$ TO $j$ \algcost{$c_4$}{$\frac{(j-2)(j-1)}{2}$}}  
      \STATE accum += $Y[p]$
        \algcost{$c_5$}{$\frac{(j-2)(j-1)}{2}$}
    \ENDFOR  
    \STATE accum = $X[i]/$accum
      \algcost{$c_6$}{$j-1$}
    \STATE match, pmin = \textsc{Min-Matching-Recursive}$(X,Y,i-1,k)$ \\
      \algcost{$T_m(i-1,j-1)$}{$\ \ \ \ \ \ \ \ \ \ \ \ 2$}
    \IF{Min$>$accum+pmin \algcost{$c_7$}{$j-1$}} 
      \STATE Min = accum + pmin
        \algcost{$c_8$}{$j-1$}
      \STATE Match = match
        \algcost{$c_9$}{$j-1$}
    \ENDIF 
  \ENDFOR
  \RETURN Match$\ \cup \ \{[i,j]\},$ Min
    \algcost{$c_1$}{$1$}
\end{algorithmic}

\subsubsection*{Tiempo de ejecución: Division}

\noindent Para $T_d(i,j)$ el tiempo de ejecución con un array de tamaño p como entrada, tenemos que
\begin{eqnarray*}
T_d(i,j)&=&c_1+c_2+c_3\cdot (j-1)+c_4\cdot \frac{(j-2)(j-1)}{2}+c_5\cdot \frac{(j-2)(j-1)}{2}+c_6\cdot (j-1)+\\
& &2\cdot T_m(i-1,j-1)+c_7\cdot (j-1)+c_8\cdot (j-1)+c_9\cdot (j-1)+c_1\\
T_d(i,j)&=&2\cdot T_m(i-1,j-1)+\frac{c_4}{2}\cdot j^2+\frac{c_5}{2}\cdot j^2-3c_4\cdot j-3c_5\cdot j+c_6\cdot j+c_7\cdot j+ \\
& &c_8\cdot j+c_9\cdot j+2c_1+c_2-c_3+3c_4+3c_5-c_6-c_7-c_8-c_9 
\end{eqnarray*}

\noindent Si $a=\frac{c_4}{2}+\frac{c_5}{2}$, $b=-3c_4-3c_5+c_6+c_7+c_8+c_9$ y $c=2c_1+c_2-c_3+3c_4+3c_5-c_6-c_7-c_8-c_9$, entonces
$$T_d(i,j)=2\cdot T_m(i-1,j-1)+aj^2+bj+c$$

\subsubsection*{Algoritmo: Min-Matching-Recursive}

\begin{algorithmic}[1]
  \TITLE{\textsc{Min-Matching-Recursive}$(X,Y,i,j)$}
    \algcost{\textit{cost}}{\textit{times}}
  \IF{$i==1$ \AND $j==1$ \algcost{$c_1$}{$1$}} 
    \RETURN $\{[i,j]\}, \ \frac{X[i]}{Y[i]}$
      \algcost{$c_2$}{$1$}
  \ENDIF 
  \IF{$i==1$ \AND $j>1$ \algcost{$c_3$}{$1$}} 
    \STATE match = \{\}
      \algcost{$c_4$}{$1$}
    \STATE accumY = 0
      \algcost{$c_5$}{$1$}
  	\FOR{$p=1$ TO $j$ \algcost{$c_6$}{$j+1$}}  
      \STATE accumY += Y[p]
        \algcost{$c_7$}{$j$}
      \STATE Match = Match$\ \cup \ \{[i,p]\},$ 
        \algcost{$c_8$}{$j$}
    \ENDFOR 
    \RETURN Match$, \ \frac{X[i]}{accumY}$
      \algcost{$c_2$}{$1$}
  \ENDIF 
  \IF{$i>1$ \AND $j==1$ \algcost{$c_3$}{$1$}} 
    \STATE match = \{\}
      \algcost{$c_4$}{$1$}
    \STATE accumX = 0
      \algcost{$c_5$}{$1$}
  	\FOR{$p=1$ TO $i$ \algcost{$c_6$}{$i+1$}}  
      \STATE accumX += X[p]
        \algcost{$c_7$}{$i$}
      \STATE Match = Match$\ \cup \ \{[p,j]\},$ 
        \algcost{$c_8$}{$i$}
    \ENDFOR 
    \RETURN $Match, \ \frac{accumX}{Y[j]}$
      \algcost{$c_2$}{$1$}
  \ENDIF 
  \STATE MatchG, MinG = \textsc{Group}$(X,Y,i,j)$
    \algcost{$T_g(i,j)$}{$1$}
  \STATE MatchD, MinD = \textsc{Division}$(X,Y,i,j)$
    \algcost{$T_d(i,j)$}{$1$}  
  \IF{MinG$>$MinD \algcost{$c_3$}{$1$}} 
    \RETURN MatchD, MinD
      \algcost{$c_2$}{$1$}
  \ENDIF  
  \RETURN MatchG, MinG
    \algcost{$c_2$}{$1$}

\end{algorithmic}

\subsubsection*{Tiempo de ejecución: Min-Matching-Recursive}

\[
T_m(i,j)=\left\{
            \begin{array}{ll}
              1 \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ i=1 \ \ \wedge \ \ j=1 \\ \\
              j \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ i=1 \ \ \wedge \ \ j>1 \\ \\
              i \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ i>1 \ \ \wedge \ \ j=1 \\ \\
              4T_m(i-1,j-1)+i^2+i+j^2+j \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ i>1 \ \ \wedge \ \ j>1 \\
            \end{array}
          \right.
\]

\subsubsection*{Resolver la recurrencia: Min-Matching-Recursive}
\noindent El análisis será para el caso en el que $i=j$ debido a que es el peor caso. Entonces, tenemos que
\begin{eqnarray*}
T_m(i,i) &=& 4T_m(i-1,i-1) + i(i+1) + i(i+1) \\
&=& 4T_m(i-1,i-1) + 2i(i+1) \\
&=& 4(4T_m(i-2,i-2) + 2(i-1)i) + 2i(i+1) \\
&=& 4^2T_m(i-2,i-2) + 4\cdot 2(i-1)i + 2i(i+1) \\
&=& 4^2(4T_m(i-3,i-3) + 2(i-2)(i-1)) + 4\cdot 2(i-1)i + 2i(i+1) \\
&=& 4^3T_m(i-3,i-3) + 4^2\cdot 2(i-2)(i-1) + 4\cdot 2(i-1)i + 2i(i+1) \\
&=& 4^3T_m(i-3,i-3) + 2\sum_{k=0}^{2} 4^k\cdot (i-k-1)(i-k) \\
&=& 4^lT_m(i-l,i-l) + 2\sum_{k=0}^{l-1} 4^k\cdot (i-k-1)(i-k) \\
&=& 4^{i-1}T_m(i-(i-1),i-(i-1)) + 2\sum_{k=0}^{i-2} 4^k\cdot (i-k-1)(i-k) \\
&=& 4^{i-1} + 2\sum_{k=0}^{i-2} 4^k\cdot (i^2+k^2-2ki-i+k) \\
\end{eqnarray*}

\noindent Ahora suponemos que $i=2^p$
\begin{eqnarray*}
T_m(i,i) &=& 4^{i-1} + 2\sum_{k=0}^{i-2} 4^k\cdot (2^{2p}+2^{k}-2\cdot 2^{k}\cdot 2^p-2^p+2^k) \\
&=& 4^{i-1} + 2\sum_{k=0}^{i-2} 2^{2k}\cdot (2^{2p}+2^{k}-2\cdot 2^{k}\cdot 2^p-2^p+2^k) \\
&=& 4^{i-1} + 2\sum_{k=0}^{i-2} 2^{2k}\cdot 2^{2p} + 2\sum_{k=0}^{i-2}(2^{k}-2\cdot 2^{k}\cdot 2^p-2^p+2^k) \\
&=& 4^{i-1} + 2\cdot 2^{2p}\sum_{k=0}^{i-2} 2^{2k} + 2\sum_{k=0}^{i-2}2^{3k} - 2^2\cdot 2^p\sum_{k=0}^{i-2}2^{3k} - 2\cdot 2^p\sum_{k=0}^{i-2}2^k + 2\sum_{k=0}^{i-2}2^{2k} \\
&=& 4^{i-1} + 2\cdot 2^{2p}\sum_{k=0}^{i-2} 4^{k} + 2\sum_{k=0}^{i-2}8^{k} - 2^2\cdot 2^p\sum_{k=0}^{i-2}8^{k} - 2\cdot 2^p\sum_{k=0}^{i-2}2^k + 2\sum_{k=0}^{i-2}4^{k} \\
&=& 4^{i-1} + 2\cdot 2^{2p}\frac{4^{i-2}-1}{3} + 2\frac{8^{i-2}-1}{7} - 2^2\cdot 2^p\frac{8^{i-2}-1}{7} - 2\cdot 2^p\frac{2^{i-2}-1}{1} + 2\frac{4^{i-2}-1}{3} \\
&=& 4^{i-1} + 2 i^{2}\frac{4^{i-2}-1}{3} + 2\frac{8^{i-2}-1}{7} - 4 i\frac{8^{i-2}-1}{7} - 2i\frac{2^{i-2}-1}{1} + 2\frac{4^{i-2}-1}{3}
\end{eqnarray*}

\noindent Además, sabemos que si $i\neq j$

$$T_m(i,j) \leq T_m(max(i,j),max(i,j))$$

\noindent Entonces, tenemos que

$$0\leq 2^{max(i,j)} \leq T_m(i,j) $$

\noindent Entonces por definición, concluimos que $$T(n,m) =  \Omega(2^{max(n,m)})$$

\subsection*{Pregunta 4 (Memoizado)}

\noindent Los algoritmos para las funciones group y división permanecen igual. La diferencia con el algoritmo 
recursivo es que almacena los datos ya calculados en una matriz de tamaño $m\ *\ n$ para evitar llamadas que 
calculen datos que ya sabemos. Dado esto y la definición de nuestra recurrencia en la pregunta 2, esta claro que el 
algoritmo va a tener tiempo de ejecución $\Theta(n*m)$ ya que es el tiempo que toma llenar toda la matriz. El algoritmo 
funciona de la siguiente manera:\\
\\\textbf{Recibe:} Dos arreglos de bits, X y Y con la cantidad de pesos que tienen i y j respectivamente.
\\\textbf{Devuelve:} El matching de peso mínimo junto con su peso.

\subsubsection*{Algoritmo: Min-Matching-Memoization}

\begin{algorithmic}[1]
  \TITLE{\textsc{Min-Matching-Memoization}$(X,Y,i,j)$}
    \algcost{\textit{cost}}{\textit{times}}
  \IF{$minMatch[i][j][2]!=\infty$ \algcost{$c_1$}{$1$}} 
    \RETURN $minMatch[i][j][1], \ minMatch[i][j][2]$
      \algcost{$c_2$}{$1$}
  \ENDIF 
  \IF{$i==1$ \AND $j==1$ \algcost{$c_3$}{$1$}} 
    \STATE $minMatch[i][j][1] = [(i,j)]$
      \algcost{$c_4$}{$1$}
    \STATE $minMatch[i][j][2] = \frac{X[i]}{Y[j]}$
      \algcost{$c_5$}{$1$}
    \RETURN $minMatch[i][j][1], \ minMatch[i][j][2]$
      \algcost{$c_6$}{$1$}
  \ENDIF 
  \IF{$i==1$ \AND $j>1$ \algcost{$c_7$}{$1$}} 
    \STATE match = \{\}
      \algcost{$c_8$}{$1$}
    \STATE accumY = 0
      \algcost{$c_9$}{$1$}
  	\FOR{$p=1$ TO $j$ \algcost{$c_{10}$}{$j$}}  
      \STATE accumY += Y[p]
        \algcost{$c_{11}$}{$1$}
      \STATE Match = Match$\ \cup \ \{[i,p]\},$ 
        \algcost{$c_{12}$}{$1$}
    \ENDFOR 
    \STATE $minMatch[i][j][1] = Match$
      \algcost{$c_{13}$}{$1$}
    \STATE $minMatch[i][j][2] = \frac{X[i]}{accumY}$
      \algcost{$c_{14}$}{$1$}
    \RETURN $minMatch[i][j][1], \ minMatch[i][j][2]$
      \algcost{$c_{15}$}{$1$}
  \ENDIF 
  \IF{$i>1$ \AND $j==1$ \algcost{$c_{16}$}{$1$}} 
    \STATE match = \{\}
      \algcost{$c_{17}$}{$1$}
    \STATE accumX = 0
      \algcost{$c_{18}$}{$1$}
  	\FOR{$p=1$ TO $i$ \algcost{$c_{19}$}{$i$}}  
      \STATE accumX += X[p]
        \algcost{$c_{20}$}{$1$}
      \STATE Match = Match$\ \cup \ \{[p,j]\},$ 
        \algcost{$c_{21}$}{$1$}
    \ENDFOR 
    \STATE $minMatch[i][j][1] = Match$
      \algcost{$c_{22}$}{$1$}
    \STATE $minMatch[i][j][2] = \frac{accumX}{Y[j]}$
      \algcost{$c_{23}$}{$1$}
    \RETURN $minMatch[i][j][1], \ minMatch[i][j][2]$
      \algcost{$c_{24}$}{$1$}
  \ENDIF 
  \STATE MatchG, MinG = \textsc{Group}$(X,Y,i,j)$
    \algcost{$i*j$}{$1$}
  \STATE MatchD, MinD = \textsc{Division}$(X,Y,i,j)$
    \algcost{$i*j$}{$1$}  
  \IF{MinG$>$MinD \algcost{$c_{25}$}{$1$}} 
    \RETURN MatchD, MinD
      \algcost{$c_{26}$}{$1$}
  \ENDIF  
  \RETURN MatchG, MinG
    \algcost{$c_{27}$}{$1$}
\end{algorithmic}

\subsection*{Pregunta 5 (Programación Dinámica)}

\subsection*{Link del repositorio}
\noindent \href{https://www.github.com/DiegoELT/ADAProject}{Github link.}


\end{document}
