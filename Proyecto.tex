\documentclass[12pt]{article}
\usepackage[margin=1in]{geometry} 
\usepackage{amsmath,amsthm,amssymb,amsfonts}
\usepackage[spanish]{babel}
\usepackage[utf8]{inputenc}
\usepackage{mathtools}
\selectlanguage{spanish}
\newcommand{\N}{\mathbb{N}}
\newcommand{\Z}{\mathbb{Z}}
\usepackage{color}
\usepackage{graphicx}
\usepackage[noend]{algorithmic}

\newenvironment{solution}
  {\renewcommand\qedsymbol{$\blacksquare$}\begin{proof}[Solución]}
  {\end{proof}}

%pseudocodigo
\newcommand{\TITLE}[1]{\item[#1]}
\renewcommand{\algorithmiccomment}[1]{$/\!/$ \parbox[t]{4.5cm}{\raggedright #1}}
% ugly hack for for/while
\newbox\fixbox
\renewcommand{\algorithmicdo}{\setbox\fixbox\hbox{\ {} }\hskip-\wd\fixbox}
% end of hack
%imitando para if
\renewcommand{\algorithmicthen}{\setbox\fixbox\hbox{\ {} }\hskip-\wd\fixbox}
\newcommand{\algcost}[2]{\strut\hfill\makebox[1.5cm][l]{#1}\makebox[4cm][l]{#2}}

%piso techo 
\DeclarePairedDelimiter\ceil{\lceil}{\rceil}
\DeclarePairedDelimiter\floor{\lfloor}{\rfloor}
 
 \newenvironment{ejercicio}[2][Ejercicio]{\begin{trivlist}
\item[\hskip \labelsep {\bfseries #1}\hskip \labelsep {\bfseries #2.}]}{\end{trivlist}}

\newenvironment{problem}[2][Problem]{\begin{trivlist}
\item[\hskip \labelsep {\bfseries #1}\hskip \labelsep {\bfseries #2.}]}{\end{trivlist}}


\begin{document}

\title{PROYECTO DE ADA}
\date{}
\maketitle

\section*{Secuencias}

\subsection*{Pregunta 1 (Voraz)}

\subsubsection*{Algoritmo: Get-Blocks}

\noindent Recibe: Un arreglos A de ceros y unos.

\noindent Devuelve: Un arreglo X de bloques de unos. 

\begin{algorithmic}[1]
  \TITLE{\textsc{Get-Blocks}$(A,p)$}
    \algcost{\textit{cost}}{\textit{times}}
  \STATE i = 1
    \algcost{$c_1$}{$1$}
  \STATE j = 1
    \algcost{$c_1$}{$1$}
  \WHILE{$i\leq p$
    \algcost{$c_3$}{$1$}}
  \STATE tmp = 0
    \algcost{$c_1$}{$1$}
    \WHILE{$A[i]\neq 1$
      \algcost{$c_4$}{$1$}}
    \STATE i += 1
      \algcost{$c_5$}{$0$}
    \ENDWHILE
    \WHILE{$A[i]\neq 0$
      \algcost{$c_4$}{$p+1$}}
    \STATE i += 1
      \algcost{$c_5$}{$p$}
    \STATE tmp += 1
      \algcost{$c_5$}{$p$}
    \ENDWHILE
  	\IF{tmp $\neq 0$ \algcost{$c_6$}{$1$}} 
    \STATE X[j] = tmp
      \algcost{$c_7$}{$1$}
    \STATE j += 1
      \algcost{$c_5$}{$1$}
    \ENDIF 
  \ENDWHILE
  \STATE return X
    \algcost{$c_8$}{$1$}
\end{algorithmic} 

\subsubsection*{Tiempo de ejecución: Get-Blocks}

\noindent Para T(n) el tiempo de ejecución con un array de tamaño p como entrada, tenemos que
\begin{eqnarray*}
T(n)&=&c_1+c_1+c_3+c_1+c_4+c_4\cdot (p+1)+c_5\cdot p+c_5\cdot p+c_6+c_7+c_5+c_8 \\
T(n)&=&c_4\cdot p+2c_5\cdot p+3c_1+c_3+2c_4+c_5+c_6+c_7+c_8 
\end{eqnarray*}

\noindent Si $a=c_4+2c_5$ y $b=3c_1+c_3+2c_4+c_5+c_6+c_7+c_8$, entonces
$$T(n)=ap+b$$

\noindent \textbf{Nota: } Para el análisis de los algoritmos propuestos en los siguientes apartados no se tomará en cuenta el tiempo de generar los bloques en los array de entrada.

\subsubsection*{Algoritmo: Min-Matching-Greedy}

\noindent Recibe: Dos arreglos A y B de ceros y unos de tamaño p, con n bloques y m bloques respectivamente (los valores de n y m no son recibidos como entrada). 

\noindent Devuelve: Un matching entre A y B, no necesariamente óptimo, y su peso.

\begin{algorithmic}[1]
  \TITLE{\textsc{Min-Matching-Greedy}$(A,B)$}
    \algcost{\textit{cost}}{\textit{times}}
  \STATE X = Get-Blocks(A,p)
    \algcost{$.$}{$.$}
  \STATE Y = Get-Blocks(B,p)
    \algcost{$.$}{$.$}
  \STATE n = X.size
    \algcost{$c_1$}{$1$}
  \STATE m = Y.size
    \algcost{$c_2$}{$1$}  
  \STATE Match = $\emptyset$
    \algcost{$c_3$}{$1$}
  \STATE $w = 0$
    \algcost{$c_4$}{$1$}
  \FOR{$i=1$ TO $min(n,m)-1$
    \algcost{$c_5$}{$m$}}  
  \STATE Match = Match $\cup \ \{\{i,i\}\}$
    \algcost{$c_6$}{$m-1$}
  \STATE $w$ += X[i]/Y[i]
    \algcost{$c_7$}{$m-1$}
  \ENDFOR  
  \IF{$n>m$ \algcost{$c_8$}{$1$}} 
    \FOR{$i=0$ TO $n-m$
    \algcost{$c_5$}{$n-m+1$}}  
    \STATE Match = Match $\cup \ \{\{m+i,m\}\}$
      \algcost{$c_6$}{$n-m$}
    \STATE $w$ += X[m+i]/Y[m]
      \algcost{$c_7$}{$n-m$}
    \ENDFOR 
  \ELSE
    \FOR{$i=0$ TO $n-m$
    \algcost{$c_5$}{$0$}}  
    \STATE Match = Match $\cup \ \{\{n,n+i\}\}$
      \algcost{$c_6$}{$0$}
    \STATE $w$ += X[n]/Y[n+i]
      \algcost{$c_7$}{$0$}
    \ENDFOR 
  \ENDIF 
  
  \STATE return $w$, Match
    \algcost{$c_9$}{$1$}
\end{algorithmic}

\subsubsection*{Tiempo de ejecución: Min-Matching-Greedy}

\noindent Para T(n,m) el tiempo de ejecución con un array de tamaño p como entrada, tenemos que
\begin{eqnarray*}
T(n,m)&=&c_1+c_2+c_3+c_4+c_5\cdot m+c_6\cdot (m-1)+c_7\cdot (m-1)+c_8+c_5\cdot (n-m+1)+\\
& &c_6\cdot (n-m)+c_7\cdot (n-m)+c_9 \\
T(n,m)&=&c_5\cdot m+c_6\cdot m+c_7\cdot m-c_5\cdot m-c_6\cdot m-c_7\cdot m+c_5\cdot n+c_6\cdot n+c_7\cdot n+c_1 \\
& &+c_2+c_3+c_5-c_6-c_7+c_8+c_9 
\end{eqnarray*}

\noindent Si $a=c_5+c_6+c_7-c_5-c_6-c_7=0$, $b=c_5+c_6+c_7$ y $c=c_1+c_2+c_3+c_5-c_6-c_7+c_8+c_9$, entonces si $n>m$
$$T(n,m)=bn+c$$
Y si $m>n$, tenemos que
$$T(n,m)=am+c$$
Entonces, podemos generalizarlo como
$$T(n,m)=max(am,bn)+c$$


\noindent \textbf{Prueba que $T(n) = O(max(n,m))$} \\

\noindent Note que para $n_0\geq max(a,b)+1$, tenemos que 
\begin{eqnarray*}
max(am,bn)+c &\leq& max(max(a,b)\cdot m, max(a,b)\cdot n)+c \\
&\leq& max(a,b)\cdot max(m,n)+c \\
&\leq& (max(a,b)+1)\cdot max(m,n) \\
&\leq& n_0\cdot max(m,n)
\end{eqnarray*}

\noindent Y como la función $max$ es creciente, tenemos que
\begin{eqnarray*}
0\leq max(am,bn)\leq n_0\cdot max(m,n)
\end{eqnarray*}
\noindent Entonces por definición, concluimos que $T(n) = O(max(n,m))$

\subsection*{Pregunta 2 (Recurrencia)}

\noindent Asumimos que:\\
$X = \textsc{Get-Blocks}(A,p)$ \\
$Y = \textsc{Get-Blocks}(B,p)$ 

\[
OPT(i,j)=\left\{
            \begin{array}{ll}
              \frac{X_i}{Y_j} \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ i=1 \ \ \wedge \ \ j=1 \\ \\
              \frac{X_i}{\sum_{p=1}^{j}Y_p} \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ i=1 \ \ \wedge \ \ j>1 \\ \\
              \frac{\sum_{p=1}^{i}X_p}{Y_j} \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ i>1 \ \ \wedge \ \ j=1 \\ \\
              min(M_g(i,j), M_d(i,j)) \ \ \ \ \ \ \ \ \ \ \ \ \ \  \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ i>1 \ \ \wedge \ \ j>1 \\
            \end{array}
          \right.
\]

\noindent
$M_g(i,j) = min_{k=1}^{i-1}\{\frac{\sum_{p=k+1}^{i}X_p}{Y_j} + OPT(k,j-1)\}$ \\ \\
$M_d(i,j) = min_{k=1}^{j-1}\{\frac{X_i}{\sum_{p=k+1}^{j}Y_p} + OPT(i-1,k)\}$

\subsection*{Pregunta 3 (Recursivo)}

\noindent Asumimos que:\\
$X = \textsc{Get-Blocks}(A,p)$ \\
$Y = \textsc{Get-Blocks}(B,p)$ 

\subsubsection*{Algoritmo: Group}

\begin{algorithmic}[1]
  \TITLE{\textsc{Group}$(X,Y,i,j)$}
    \algcost{\textit{cost}}{\textit{times}}
  \STATE Min = $\infty$
    \algcost{$.$}{$.$}
  \FOR{$k=1$ TO $i-1$ \algcost{$.$}{$.$}}  
    \STATE accum = 0
      \algcost{$.$}{$.$}
    \FOR{$p=k+1$ TO $i$ \algcost{$.$}{$.$}}  
      \STATE accum += $X[p]$
        \algcost{$.$}{$.$}
    \ENDFOR  
    \STATE accum /= $Y[j]$
      \algcost{$.$}{$.$}
    \STATE match, pmin = \textsc{Min-Matching-Recursive}$(X,Y,k,j-1)$ \\
      \algcost{$.$}{$.$}
    \IF{Min$>$accum+pmin \algcost{$.$}{$.$}} 
      \STATE Min = accum + pmin
        \algcost{$.$}{$.$}
      \STATE Match = match
        \algcost{$.$}{$.$}
    \ENDIF 
  \ENDFOR  
  \RETURN Match$\ \cup \ \{[i,j]\},$ Min
    \algcost{$.$}{$.$}
\end{algorithmic}

\subsubsection*{Algoritmo: Division}

\begin{algorithmic}[1]
  \TITLE{\textsc{Division}$(X,Y,i,j)$}
    \algcost{\textit{cost}}{\textit{times}}
  \STATE Min = $\infty$
    \algcost{$.$}{$.$}
  \FOR{$k=1$ TO $j-1$ \algcost{$.$}{$.$}}  
    \STATE accum = 0
      \algcost{$.$}{$.$}
    \FOR{$p=k+1$ TO $j$ \algcost{$.$}{$.$}}  
      \STATE accum += $Y[p]$
        \algcost{$.$}{$.$}
    \ENDFOR  
    \STATE accum = $X[i]/$accum
      \algcost{$.$}{$.$}
    \STATE match, pmin = \textsc{Min-Matching-Recursive}$(X,Y,i-1,k)$ \\
      \algcost{$.$}{$.$}
    \IF{Min$>$accum+pmin \algcost{$.$}{$.$}} 
      \STATE Min = accum + pmin
        \algcost{$.$}{$.$}
      \STATE Match = match
        \algcost{$.$}{$.$}
    \ENDIF 
  \ENDFOR
  \RETURN Match$\ \cup \ \{[i,j]\},$ Min
    \algcost{$.$}{$.$}
\end{algorithmic}

\subsubsection*{Algoritmo: Min-Matching-Recursive}

\begin{algorithmic}[1]
  \TITLE{\textsc{Min-Matching-Recursive}$(X,Y,i,j)$}
    \algcost{\textit{cost}}{\textit{times}}
  \IF{$i==1$ \AND $j==1$ \algcost{$.$}{$.$}} 
    \RETURN $\{[i,j]\}, \ \frac{X[i]}{Y[i]}$
      \algcost{$.$}{$.$}
  \ENDIF 
  \IF{$i==1$ \AND $j>1$ \algcost{$.$}{$.$}} 
    \STATE match = \{\}
      \algcost{$.$}{$.$}
    \STATE accumY = 0
      \algcost{$.$}{$.$}
  	\FOR{$p=1$ TO $j$ \algcost{$.$}{$.$}}  
      \STATE accumY += Y[p]
        \algcost{$.$}{$.$}
      \STATE Match = Match$\ \cup \ \{[i,p]\},$ 
        \algcost{$.$}{$.$}
    \ENDFOR 
    \RETURN Match$, \ \frac{X[i]}{accumY}$
      \algcost{$.$}{$.$}
  \ENDIF 
  \IF{$i>1$ \AND $j==1$ \algcost{$.$}{$.$}} 
    \STATE match = \{\}
      \algcost{$.$}{$.$}
    \STATE accumX = 0
      \algcost{$.$}{$.$}
  	\FOR{$p=1$ TO $i$ \algcost{$.$}{$.$}}  
      \STATE accumX += X[p]
        \algcost{$.$}{$.$}
      \STATE Match = Match$\ \cup \ \{[p,j]\},$ 
        \algcost{$.$}{$.$}
    \ENDFOR 
    \RETURN $Match, \ \frac{accumX}{Y[j]}$
      \algcost{$.$}{$.$}
  \ENDIF 
  \STATE MatchG, MinG = \textsc{Group}$(X,Y,i,j)$
    \algcost{$.$}{$.$}
  \STATE MatchD, MinD = \textsc{Division}$(X,Y,i,j)$
    \algcost{$.$}{$.$}  
  \IF{MinG$>$MinD \algcost{$.$}{$.$}} 
    \RETURN MatchD, MinD
      \algcost{$.$}{$.$}
  \ENDIF  
  \RETURN MatchG, MinG
    \algcost{$.$}{$.$}

\end{algorithmic}

\subsection*{Pregunta 4 (Memoizado)}

\noindent Los algoritmos para las funciones group y división permanecen igual.

\subsubsection*{Algoritmo: Min-Matching-Memoization}

\begin{algorithmic}[1]
  \TITLE{\textsc{Min-Matching-Memoization}$(X,Y,i,j)$}
    \algcost{\textit{cost}}{\textit{times}}
  \IF{$minMatch[i][j][2]!=\infty$ \algcost{$.$}{$.$}} 
    \RETURN $minMatch[i][j][1], \ minMatch[i][j][2]$
      \algcost{$c_1$}{$1$}
  \ENDIF 
  \IF{$i==1$ \AND $j==1$ \algcost{$.$}{$.$}} 
    \STATE $minMatch[i][j][1] = [(i,j)]$
      \algcost{$c_2$}{$1$}
    \STATE $minMatch[i][j][2] = \frac{X[i]}{Y[j]}$
      \algcost{$c_3$}{$1$}
    \RETURN $minMatch[i][j][1], \ minMatch[i][j][2]$
      \algcost{$c_4$}{$1$}
  \ENDIF 
  \IF{$i==1$ \AND $j>1$ \algcost{$.$}{$.$}} 
    \STATE match = \{\}
      \algcost{$c_5$}{$1$}
    \STATE accumY = 0
      \algcost{$c_6$}{$1$}
  	\FOR{$p=1$ TO $j$ \algcost{$c_7$}{$j$}}  
      \STATE accumY += Y[p]
        \algcost{$c_8$}{$1$}
      \STATE Match = Match$\ \cup \ \{[i,p]\},$ 
        \algcost{$c_9$}{$1$}
    \ENDFOR 
    \STATE $minMatch[i][j][1] = Match$
      \algcost{$c_{10}$}{$1$}
    \STATE $minMatch[i][j][2] = \frac{X[i]}{accumY}$
      \algcost{$c_{11}$}{$1$}
    \RETURN $minMatch[i][j][1], \ minMatch[i][j][2]$
      \algcost{$c_{12}$}{$1$}
  \ENDIF 
  \IF{$i>1$ \AND $j==1$ \algcost{$.$}{$.$}} 
    \STATE match = \{\}
      \algcost{$c_{13}$}{$1$}
    \STATE accumX = 0
      \algcost{$c_{14}$}{$1$}
  	\FOR{$p=1$ TO $i$ \algcost{$c_{15}$}{$i$}}  
      \STATE accumX += X[p]
        \algcost{$c_{16}$}{$1$}
      \STATE Match = Match$\ \cup \ \{[p,j]\},$ 
        \algcost{$c_{17}$}{$1$}
    \ENDFOR 
    \STATE $minMatch[i][j][1] = Match$
      \algcost{$c_{18}$}{$1$}
    \STATE $minMatch[i][j][2] = \frac{accumX}{Y[j]}$
      \algcost{$c_{19}$}{$1$}
    \RETURN $minMatch[i][j][1], \ minMatch[i][j][2]$
      \algcost{$c_{20}$}{$1$}
  \ENDIF 
  \STATE MatchG, MinG = \textsc{Group}$(X,Y,i,j)$
    \algcost{$i*j$}{$1$}
  \STATE MatchD, MinD = \textsc{Division}$(X,Y,i,j)$
    \algcost{$i*j$}{$1$}  
  \IF{MinG$>$MinD \algcost{$.$}{$.$}} 
    \RETURN MatchD, MinD
      \algcost{$c_{21}$}{$1$}
  \ENDIF  
  \RETURN MatchG, MinG
    \algcost{$c_{22}$}{$1$}
\end{algorithmic}

\subsection*{Pregunta 5 (Programación Dinámica)}





\end{document}
